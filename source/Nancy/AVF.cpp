#include <sstream>
#include <SDL2/SDL_image.h>

#include <oldhertools/lzss.hpp>
#include <oldhertools/crypt_misc.hpp>
#include <oldhertools/colorspace.hpp>

#include "Nancy/AVF.h"
#include "Engine/utils.h"
#include <oldhertools/avf.hpp>

#include <png++/png.hpp>
#include <iostream>
#include <iomanip>

//TODO: Everything touched by avf leaks memory becasue it is static
std::vector<SDL_Texture_ptr> AVF::parseAVF(const char* file)
{
	std::ifstream inFile = std::ifstream(file, std::ios::in | std::ios::binary | std::ios::ate);
	if (inFile.fail()) {
		inFile.close();
		printf("Unable to open AVF file:%s\n", file);
		return std::vector<SDL_Texture_ptr>();
	}

	inFile.seekg(0);

	std::string magic = readString(inFile, 15);
	if (magic != "AVF WayneSikes")
	{
		printf("Invalid header in file: %s\n", file);
		return std::vector<SDL_Texture_ptr>();
	}

	//ver major													ver minor
	if (!AssertShort(inFile, 2, true) || !AssertShort(inFile, 0, true))
	{
		printf("Invalid version in file: %s\n", file);
		return std::vector<SDL_Texture_ptr>();
	}

	int unknown = readShort(inFile);

	int numEntries = readShort(inFile);
	int width = readShort(inFile);
	int height = readShort(inFile);

	//From OldHerTools
	std::vector<Her::AVF_idxEntry> jumpList = Her::getAVFindex(inFile, numEntries);

	std::vector<SDL_Texture_ptr> frames;
	char* rawData;

	for (auto& i : jumpList) {
		inFile.seekg(i.startAt);
		rawData = new char[i.goFor];
		inFile.read(rawData, i.goFor);
		// decrypt & decompress bytes
		std::vector<uint8_t> frame = Her::dec_LZSS(Her::sub_offsets(rawData, i.goFor));

		if (numEntries == 1)
			frames.push_back(SDL_Texture_ptr(AVFBMP(frame, width, height)));
		else
			frames.push_back(SDL_Texture_ptr(AVFPNG(frame, width, height)));

		delete[] rawData;
	}

	inFile.close();

	return frames;
}

SDL_Texture* AVF::AVFPNG(std::vector<uint8_t> frame, int width, int height)
{
	png::image<png::rgb_pixel> frameimg = Her::MakePNG(frame, width, height);

	frameimg.write("tmp.png");
	//SDL_RWops* rw = SDL_RWFromMem(buffer2, size);
	SDL_RWops* rw = SDL_RWFromFile("tmp.png", "r");
	SDL_Texture* buffer = IMG_LoadTexture_RW(Graphics::renderer.get(), rw, 1); //1 means free rw after loading
	if (buffer == NULL)
	{
		printf("Failed to load AVF: %s\n",
			IMG_GetError());
		return NULL;
	}

	return buffer;
}

SDL_Texture* AVF::AVFBMP(std::vector<uint8_t> frame, int width, int height)
{
	std::vector<uint8_t> frameConv = Her::RGB555_888BGR(frame);

	std::vector<uint8_t> bmpHeader = createBMPHeader(frameConv.size(), width, height);
	frameConv.insert(frameConv.begin(), bmpHeader.begin(), bmpHeader.end());

	SDL_RWops* rw = SDL_RWFromMem(frameConv.data(), frameConv.size());

	//Solution generated by Bing chat. Doesn't work because no bmp header on data
		///////////////

		/*//Create a memory stream from the char vector
		SDL_RWops* rw = SDL_RWFromMem(frameConv.data(), frameConv.size());
		if (rw == NULL)
		{
			printf("Failed to create memory stream: %s\n",
				SDL_GetError());
			return NULL;
		}

		//Load image from memory stream using SDL_image
		buffer = SDL_Texture_ptr(IMG_LoadTexture_RW(Graphics::renderer.get(), rw, 1)); //1 means free rw after loading
		if (buffer == NULL)
		{
			printf("Failed to load texture: %s\n",
				IMG_GetError());
			return NULL;
		}*/

		//16jalayt's original solution
			/*SDL_Surface* tmpsurf = IMG_Load_RW(rw, 1);
			if (tmpsurf == NULL)
			{
				printf("IMG_Load_RW: %s\n", IMG_GetError());
				return NULL;
			}
			buffer = SDL_Texture_ptr(SDL_CreateTextureFromSurface(Graphics::renderer.get(), tmpsurf));
			SDL_FreeSurface(tmpsurf);*/

			//////////////////

		//This function was suggusted by Bing Chat
	SDL_Texture* buffer = IMG_LoadTexture_RW(Graphics::renderer.get(), rw, 1); //1 means free rw after loading
	if (buffer == NULL)
	{
		printf("Failed to load AVF: %s\n",
			IMG_GetError());
		return NULL;
	}
	return buffer;
}

std::vector<uint8_t>  AVF::createBMPHeader(int length, int width, int height)
{
	std::ostringstream output;
	//magic
	output.write((char const*)&"BM", sizeof(uint8_t) * 2);

	//length of file (data+header)
	int length1 = length + 54;
	output.write((char const*)&length1, 4);

	//reserved
	//Crashes when passing directly to write
	uint32_t a = 0;
	output.write((char const*)&a, 4);

	//Pixel data offset reletive to start of file
	a = 54;
	output.write((char const*)&a, 4);

	//Image header length
	a = 40;
	output.write((char const*)&a, 4);

	//width
	output.write((char const*)&width, 4);

	//height
	a = 0 - height;
	output.write((char const*)&a, 4);

	//Image planes. Must be 1
	a = 1;
	output.write((char const*)&a, 2);

	//bpp, 24
	a = 24;
	output.write((char const*)&a, 2);

	//compression type
	a = 0;
	output.write((char const*)&a, 4);

	//size of image, no compression, so 0
	output.write((char const*)&a, 4);

	//perfered width
	output.write((char const*)&a, 4);

	//prefered height
	output.write((char const*)&a, 4);

	//Colors used
	output.write((char const*)&a, 4);

	//important colors
	output.write((char const*)&a, 4);

	const std::string& str = output.str();
	std::vector<uint8_t> bmpHeader = std::vector<uint8_t>();
	bmpHeader.insert(bmpHeader.end(), str.begin(), str.end());

	return bmpHeader;
}